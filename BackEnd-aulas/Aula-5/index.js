// Importa o mÃ³dulo 'express' para criar o servidor e manipular rotas
const express = require('express')

// Importa o mÃ©todo 'uuidv4' da biblioteca 'uuid', que gera um identificador Ãºnico
const { v4: uuidv4 } = require('uuid')

// Cria uma instÃ¢ncia do aplicativo Express
const app = express()

// Configura o servidor para aceitar requisiÃ§Ãµes com dados JSON no corpo
app.use(express.json())

// Array onde armazenaremos temporariamente os projetos criados
const projects = []

// Middleware que registra as rotas e mÃ©todos das requisiÃ§Ãµes no console

function logRoutes(request, response, next) {
    // Extrai o mÃ©todo e a URL da requisiÃ§Ã£o
    const { method, url } = request

    // Formata uma string com o mÃ©todo e a URL
    const route = `[${method.toUpperCase()}] ${url}`

    // Exibe a string no console
    console.log(route)

    // Executa o prÃ³ximo middleware ou rota
    return next()
}

// Habilita o uso do middleware de log de rotas em todas as requisiÃ§Ãµes

//app.use(logRoutes)

// Rota para obter a lista de projetos

app.get('/projects', function(request, response) {
    // Retorna o array de projetos como resposta em formato JSON
    return response.json(projects)
})

// Rota para adicionar um novo projeto, com o middleware de log aplicado

app.post('/projects', logRoutes, function(request, response) {
    // Extrai 'nome' e 'responsÃ¡ve' do corpo da requisiÃ§Ã£o
    const { nome, responsÃ¡vel } = request.body

    // Cria um novo projeto com ID Ãºnico, nome e dono
    const project = {
        id: uuidv4(),
        nome,
        responsÃ¡vel    
    }

    // Adiciona o novo projeto ao array de projetos
    projects.push(project)

    // Retorna o projeto criado com status 201 (criado)
    return response.status(201).json(project)
})

// Rota para atualizar um projeto existente pelo 'id'
app.put('/projects/:id', function(request, response) {
    // Extrai o 'id' dos parÃ¢metros da URL
    const { id } = request.params

    // Extrai 'nome' e 'responsÃ¡ve' do corpo da requisiÃ§Ã£o
    const { nome, responsÃ¡vel } = request.body

    // Encontra o Ã­ndice do projeto no array que tem o ID igual ao passado
    const projectIndex = projects.findIndex(p => p.id === id)

    // Verifica se o projeto existe; se nÃ£o, retorna um erro 404
    if (projectIndex < 0) {
        return response.status(404).json({ error: 'Projeto nÃ£o encontrado' })
    }

    // Verifica se 'nome' e 'responsÃ¡ve' foram informados; se nÃ£o, retorna erro 400
    if (!nome || !responsÃ¡vel) {
        return response.status(400).json({ error: 'Nome e responsÃ¡vel sÃ£o necessÃ¡rios' })
    }

    // Cria o novo objeto do projeto com os dados atualizados
    const project = {
        id,
        nome,
        responsÃ¡vel
    }

    // Atualiza o projeto existente no array
    projects[projectIndex] = project

    // Retorna o projeto atualizado
    return response.json(project)
})

// Rota para deletar um projeto pelo 'id'
app.delete('/projects/:id', function(request, response) {
    // Extrai o 'id' dos parÃ¢metros da URL
    const { id } = request.params

    // Encontra o Ã­ndice do projeto no array com o ID especificado
    const projectIndex = projects.findIndex(p => p.id === id)

    // Verifica se o projeto existe; se nÃ£o, retorna um erro 404
    if (projectIndex < 0) {
        return response.status(404).json({ error: 'Projeto nÃ£o encontrado' })
    }

    // Remove o projeto do array
    projects.splice(projectIndex, 1)

    // Retorna uma resposta com status 204 (sem conteÃºdo), indicando exclusÃ£o
    return response.status(204).send()
})

// Configurando o servidor na porta respectiva
app.listen(3000, ()=>{
    console.log("Servidor iniciado na porta 3000!ðŸ˜Š")
})